\documentclass[letterpaper,12pt]{article}

% Packages
\usepackage{fixltx2e}
\usepackage[margin=2.54cm]{geometry}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amsthm}
\usepackage{paralist}
\usepackage{float}
\usepackage{graphicx}
\usepackage{algorithmic}
\usepackage{tikz}
\usepackage{mathpartir}
\usetikzlibrary{positioning,shadows,arrows}
\usepackage{listings}
\usepackage{caption}

\lstset{
        basicstyle=\footnotesize\ttfamily,
        numbers=left,
        numberstyle=\tiny,
        breaklines=true
        keywordstyle=\color{red},
        stringstyle=\color{white}\ttfamily,
        frame=b,
        showspaces=false,
        showtabs=false,
        xleftmargin=17pt,
        framexleftmargin=17pt,
        framexrightmargin=5pt,
        framexbottommargin=4pt,
        showstringspaces=false
}

\lstloadlanguages{
        Java
}

\DeclareCaptionFont{white}{\color{white}}
\DeclareCaptionFormat{listing}{
        \colorbox[cmyk]{0.43, 0.35, 0.35,0.01}{
                \parbox{\textwidth}{\hspace{15pt}#1#2#3}
        }
}

\captionsetup[lstlisting]{
        format=listing,
        labelfont=white,
        textfont=white,
        singlelinecheck=false,
        margin=0pt,
        font={bf,footnotesize}
}

\begin{document}

\title{Assignment 1}
\date{February 24, 2012}
\author{CPSC 433 \\ David Z. Chen}

\maketitle

\section{Asynchronous Server}

The architecture of the asynchronous server \texttt{SHTTPAsyncServer} closely follows that of the Asynchronous Server V3. A new \texttt{ReadWriteHander} (\texttt{SHTTPReadWriteHandler}) was implemented to handle HTTP requests. The request handling code was based heavily on the handler code used by the synchronous servers, \texttt{WebRequestHander}, but adapted for asynchronous socket I/O. Another change made was that the load balancing callback is now made to the \texttt{Dispatcher} object rather than the instance of the \texttt{SHTTPAsyncServer}.

In order to implement timeout, a separate thread that monitors timeout events of different opened sockets is instantiated along with the Dispatcher thread. When the Acceptor handler accepts a connection, after creating the \texttt{ReadWriteHandler}, it registers a timeout event for the \texttt{ReadWriteHandler}'s selection key. The selection key is added to the \texttt{IdleTimer}'s asynchronous queue, which is processed at the beginning of each iteration of the timeout thread's run loop. Later, when the \texttt{ReadWriteHandler} completes reading the request, it sends a cancellation request to the timeout thread, which is placed in another asynchronous queue in the timeout thread.

The timeout thread should not close the channel directly because the Dispatcher will still have the key registered and will not be able to know about the closing of the channel so that it may deregister the key. The timeout thread maintains two asynchronous queues and a \texttt{HashMap} that tracks the end-times of timeout events that are keyed by their selection key. The main loop of the timeout thread is as follows. First, it checks its timeout registration queue and adds each selection key to the HashMap with the end-time set to the current time plus the incomplete timeout set by the server's configuration file. Then, it checks its cancellation request queue and removes each of the requested timeout events from the HashMap. 

Finally, it iterates through all of the timeout events in the HashMap. For each key-value pair found, it checks whether the current time has passed the end-time. If it has, then a new \texttt{IdleTimerTask} object is created, which is a simple Runnable whose \texttt{run()} method simply calls the method of the Dispatcher to close the channel associated with a particular selection key. The Dispatcher was modified to also contain an asynchronous queue based on \texttt{invokeLater()} from Santos's article. The timer thread adds the task to the Dispatcher's asynchronous queue using \texttt{invokeLater()}, and the Dispatcher closes the channel associated with that selection key and deregisters the key.


\section{Comparison of Designs}

\subsection{Dispatcher threads}

According to the xsocket documentation, by default, xsocket creates $\text{number of CPUs} + 1$ dispatcher threads. The dispatcher threads, represented by the \texttt{IoSocketDispatcher} class, are managed in a \texttt{IoSocketDispatcherPool}.

The dispatchers are created as follows. First, a \texttt{Server} object is created. The \texttt{Server} constructor calls \texttt{ConnectionUtils.getIoProvider().createAcceptor()} on line 489. The \texttt{createAcceptor()} method of \texttt{IoProvider} (IoProvider.java line 471) instantiates a \texttt{IoAcceptor} object (IoProvider.java line 478). The \texttt{IoAcceptor} constructor instantiates a \texttt{IoSocketDispatcherPool} (IoAcceptor.java line 119), passing it a size, which \texttt{IoSocketDispatcherPool} uses when it calls \texttt{setDispatcherSize()} (IoSocketDispatcherPool.java line 77) to set the size of the dispatcher thread pool. After it sets the size, it calls \texttt{updateDispatcher()} on line 290. The first time this method is called, it notices that the number of dispatcher threads running is less than the maximum and instantiates each dispatcher thread (line 178). Before instantiating each dispatcher, it creates a \texttt{IoUnsynchronizedMemoryManager} object for the dispatcher (line 172-176).



\subsection{Workflow of dispatcher}

As described above, a dispatcher thread is represented by the \texttt{IoSocketDispatcher} class. Its constructor is defined in IoSocketDispatcher.java line 106-127. The constructor is passed a memory manager object and a string name. It then opens a \texttt{Selector}. \texttt{IoSocketDispatcher} is \texttt{Runnable}. The \texttt{run()} method of the dispatcher is as follows:

\begin{lstlisting}[label=dispatcherLoop,caption=Main loop of dispatcher]
    public void run() {
        
        // set thread name and attach dispatcher id to thread
        Thread.currentThread().setName(name);
        THREADBOUND_ID.set(id);

        DIRECT_CALL_COUNTER.set(0);

        if (LOG.isLoggable(Level.FINE)) {
            LOG.fine("selector " + name + " listening...");
        }

        int handledTasks = 0;

        while (isOpen.get()) {
            try {
                int eventCount = selector.select(5000);

                handledTasks = performRegisterHandlerTasks();
                handledTasks += performKeyUpdateTasks();

                if (eventCount > 0) {
                    handleReadWriteKeys();
                }

                handledTasks += performDeregisterHandlerTasks();

                checkForLoooping(eventCount + handledTasks, lastTimeWokeUp);
            } catch (Throwable e) {
                // eat and log exception
                if (LOG.isLoggable(Level.FINE)) {
                    LOG.fine("[" + Thread.currentThread().getName() + "] exception occurred while processing. Reason " + DataConverter.toString(e));
                }
        }
        
        for (IoSocketHandler socketHandler : getRegistered()) {
            socketHandler.onDeregisterEvent();
        }

        try {
            selector.close();
        } catch (Exception e) {
            // eat and log exception
            if (LOG.isLoggable(Level.FINE)) {
                LOG.fine("error occured by close selector within tearDown " + DataConverter.toString(e));
            }
        }
    }
\end{lstlisting}

The main loop iterates as long as the Dispatcher is open. Each time through the loop, it calls \texttt{select()} (line 224). Then, it calls \texttt{performRegisterHandlerTasks()} (line 226) which runs all of the tasks on the asynchronous queue \texttt{registerQueue} to handle each of the register handler tasks. Then, it calls texttt{performKeyUpdateTasks()} (line 227) which similarly runs each task for updating selection keys on the asynchronous queue \texttt{keyUpdateQueue}. Then, if handlers have been registered and if selection keys have been updated, it means that there could be read and write events that need to be handled. Thus, it calls \texttt{handleReadWriteKeys()} which, similar to our dispatcher, loops through the set of selection keys and calls the read and write handlers for the read and write events. Then, it calls \texttt{performDeregisterHandlerTasks()} to run the tasks on the asynchronous queue \texttt{deregisterQueue} for deregistering handlers. Finally, it checks whether the thread is idle-looping by calling the parent class's \texttt{checkForLooping()} method, which has the thread either sleep or reinitialize the selector if idle looping is detected. Finally, if the dispatcher thread has closed, the loop terminates. Then, all of the \texttt{IoSocketHandler} objects are deregistered and the selector is closed.

\subsection{\texttt{EchoHandler} calling sequence}

\subsection{Idle timeout}

\subsection{Testing}

\end{document}
